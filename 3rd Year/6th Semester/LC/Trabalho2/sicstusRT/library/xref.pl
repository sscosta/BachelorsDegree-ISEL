/* Copyright(C) 2001, Swedish Institute of Computer Science */
/*

Author: Tom Howland
Maintainer: Mats Carlsson

*/

:- module(xref, [xref/2]).

:- public xref/2.

/* xref(+Files, +Options)

"Files" must be single prolog file specification or a ground list of
prolog file specifications. The ".pl" extension may be omitted.

"Options" must be a ground list of zero or more options of the form:

     runtime_entry ... This makes the cross referencer trace from
         user:runtime_entry/1.  In its absence, it traces from
         module declarations.

     compiler_errors ... This makes the cross referencer
         generate standard compiler style error messages.

     verbose ... verbose output. This forces the cross referencer to
         echo the names of the files being read to user_error like qld
         would do.

     warnings(WFile) ...  warning file. Warnings are written to
         user_error by default. "WFile" must be a file specification.

     xref(XFile) ... cross reference file. This is not generated
         by default. "XFile" must be a file specification.

     mod(MFile) ... generate a file indicating which predicates are
         imported and which are exported for each file. This is not
         generated by default. "MFile" must be a file specification.

     undefined(UFile) ... generate a list of undefined predicates.
         References to undefined predicates are given in the warnings
         file, but sometimes you just want a list of the undefined
         predicates. "UFile" must be a file specification.

For example, the following would be a reasonable invocation:

	?- xref(foo, [verbose]).

This would check "foo.pl" for undefined and unreachable code,
generating no cross reference file, displaying warnings on user_error.

*/

:- use_module(library(assoc)).
:- use_module(library(lists), [append/3,memberchk/2]).

:- dynamic visited/1.		% so we won't visit a file twice.
:- dynamic cant_follow/7.	% a rare warning

xref(Files, Options) :-

    retractall(cant_follow(_,_,_,_,_,_,_)),
    retractall(visited(_)),

    default(runtime_entry, runtime_entry, exports, Options, TraceRoot),
    default(compiler_errors, compiler, normal, Options, CompilerErrors),
    default(verbose, verbose, silent, Options, Verbose),
    default(warnings(WFile), WFile, user_error, Options, WFile),
    default(xref(XF), file(XF), suppress, Options, XFile),
    default(mod(MF), file(MF), suppress, Options, MFile),
    default(undefined(UF), file(UF), suppress, Options, UFile),

    prolog_flag(syntax_errors, Err, dec10),
    % prolog_flag(gc_margin, Old, 9216),	% 9 times the default,
    init_d(Dict0),
    load_files(Files, [], user, '', 0-Verbose, Dict0, Dict),

    print_message(help, xref(Verbose,thinking)),
    retractall(visited(_)),
    garbage_collect_atoms,
    think(Dict, TraceRoot, MFile, UFile, R, XREF, MMD),

    print_message(help, xref(Verbose,printing)),
    print_it(WFile, R, XFile, XREF, MFile, MMD, CompilerErrors),

    print_message(help, xref(Verbose,done)),
    % prolog_flag(gc_margin, _, Old),
    prolog_flag(syntax_errors, _, Err).

default(Key, Value,     _, Options, Value) :- memberchk(Key, Options), !.
default(_,       _, Value,       _, Value).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/* this is where we read in the sources.

   The object is to create a d/6 structure representing the entire application.

   d(Defs, Imports, Externs, Initializations, MetaPredicates, Warnings)

   where

   Defs .. a list of clauses, represented as Head-Body, where

       Head is a g/3 structure, that is, a term of the form

       		g(Name, Arity, Module)

       Body is a a term clause(File, LC, Goals) where

          File is the file in which the clause was read
	  LC is the line number
	  Goals is a list of g/3 structures.

   Imports .. an avl tree. g(N,A,OldModule)-g(N,A,NewModule)

   Externs .. a list of terms of the form

   	extern(File, LC, Name, Arity, Module)

   Initializations ... a list of terms of the form

   	initialization(File, LC, Goals)

      where Goals is a list of g/3 structures.

   MetaPredicates ... an avl tree g(Name,Arity,Module)-(Head-Metas) where

      Head is a term that will unify with a meta predicate
      Metas is a list of variables occuring in Head that are the meta arguments

   Warnings is a list of error terms as handled by print_warning_list/3

This data structure is handled by the following predicates which implement an
abstract datatype suited for use in a DCG.
*/

init_d(d([],t,[],[],t,[])).

get_d_defs(Defs, d(Defs,_,_,_,_,_)).

set_d_defs(Defs0, Defs, d(Defs0,Im,Ex,In,Mt,Wrn), d(Defs,Im,Ex,In,Mt,Wrn)).

get_d_imports(Im, d(_,Im,_,_,_,_)).
get_d_imports(Im, D, D) :- get_d_imports(Im, D).
set_d_imports(Im0, Im, d(Defs,Im0,Ex,In,Mt,Wrn), d(Defs,Im,Ex,In,Mt,Wrn)).

get_d_externs(Ex, d(_,_,Ex,_,_,_)).

set_d_externs(Ex0, Ex, d(Defs,Im,Ex0,In,Mt,Wrn), d(Defs,Im,Ex,In,Mt,Wrn)).

get_d_initializations(In, d(_,_,_,In,_,_)).

set_d_initializations(In0, In, d(Defs,Im,Ex,In0,Mt,Wrn),
		      d(Defs,Im,Ex,In,Mt,Wrn)).

set_d_metas(Mt0, Mt, d(Defs,Im,Ex,In,Mt0,Wrn), d(Defs,Im,Ex,In,Mt,Wrn)).

get_d_warnings(Wrn, d(_,_,_,_,_,Wrn)).

set_d_warnings(Wrn0, Wrn, d(Defs,Im,Ex,In,Mt,Wrn0), d(Defs,Im,Ex,In,Mt,Wrn)).



load_files([], _, _, _, _) --> !.
load_files([H|T], Options, M, F, L) --> !,
    load_files(H, Options, M, F, L),
    load_files(T, Options, M, F, L).
load_files(Files, Options, _, _, _) -->
    {append(Front, [when(When)|Back], Options)},
    {When \== run_time},		% SP: always true
    {append(Front, Back, Options1)},
    {load_files(Files, Options1)},
    {When == compile_time},
    % otherwise fall through to next clause to handle runtime dependency
    !.
load_files(X, Options, Mod, F, Level-Verbose, D0, D) :-
    absolute_file_name(X, File, [file_type(source),relative_to(F)]),
    on_exception(Error, open(File, read, Stream),
		        (print_message(error, Error), fail)), !,
    read_one(Stream, Term, LC),
    (   (Term = (:-module(M,Exports)); Term = (:-module(M,Exports,_)))
    ->  (   memberchk(imports(Imports), Options), Imports \== all
	->  true
	;   Imports = Exports
	),
	imports(Mod, M, Imports, D0, D1),
	read_one(Stream, TheTerm, TheLC),
	TheMod = M
    ;   TheTerm = Term, TheLC = LC, TheMod = Mod, D1 = D0
    ),
    (   visited(File)
    ->  D = D1
    ;   print_message(help, xref(Verbose,processing(Level,File))),
	assert(visited(File)),
	L is Level+1,
        read_loop(TheTerm, Stream, TheLC, TheMod, File, L-Verbose, D1, D)
    ),
    close(Stream).
load_files(_X, _, _, _F, _) --> [].

read_one(Stream, X, LC) :-
    line_count(Stream, L0),
    LC is L0+1,
    read(Stream, Y),
    expand_term(Y, X).

imports(Mod, M, Exports, D0, D) :-
    set_d_imports(Imports0, Imports, D0, D),
    import(Exports, Mod, M, Imports0, Imports).

import([], _, _, I, I).
import([N/A|R], Mod, M, I0, I) :-
    put_assoc(g(N,A,Mod), I0, g(N,A,M), I1),
    import(R, Mod, M, I1, I).

read_loop(end_of_file, _, _,   _,    _, _,  D, D) :- !.
read_loop(X0, Stream, LC0, Mod, File, L, D0, D) :-
    recognize(X0, LC0, Mod, File, L, D0, D1),
    read_one(Stream, X, LC),
    read_loop(X, Stream, LC, Mod, File, L, D1, D).

recognize(foreign_file(_,_), _, _, _, _) --> !.
recognize(foreign_resource(_,_), _, _, _, _) --> !.
recognize([], _,  _, _, _) --> !.
recognize([H|T], LC, Mod, File, L) --> !,
    recognize(H, LC, Mod, File, L),
    recognize(T, LC, Mod, File, L).
recognize((:-G), LC, Mod, File, L) --> !,
    command(G, LC, Mod, File, L).
recognize((M:X), LC, _, File, L) --> !,
    recognize(X, LC, M, File, L).
recognize((X:-Y), LC, Mod, File, _) --> !,
    {module_prefix(X, Mod, Head, HeadC)},
    insert_clause(Head, Y, HeadC, LC, Mod, File).
recognize(foreign(_,_,G), LC, Mod, File, _) --> !,
    insert_clause(G, true, Mod, LC, Mod, File).
recognize(foreign(_,G), LC, Mod, File, _) --> !,
    insert_clause(G, true, Mod, LC, Mod, File).
recognize(X, LC, Mod, File, _) -->
    insert_clause(X, true, Mod, LC, Mod, File).

command((X,Y), LC, M, F, L) --> !,
    command(X, LC, M, F, L),
    command(Y, LC, M, F, L).
command(op(P,T,O), _, _, _, _) --> !,
    {op(P,T,O)}.
command(initialization(Body), LC, Mod, File, _) --> !,
    set_d_initializations(In, [initialization(File,LC,B)|In]),
    get_d_imports(Im),
    set_d_metas(Mt0, Mt),
    { body(Body, x('', initialization,1,LC,Mod,File,Im,Mt0), B, []),
      record_non_metas(B, Mt0, Mt)
    }.
command(meta_predicate(Meta), LC, Mod, File, _) --> !,
    set_d_warnings(Wrn0, Wrn),
    set_d_metas(M0, M),
    { parse_metas(Meta, Mod, File, LC, Wrn0, Wrn, M0, M) }.
command(dynamic(Dynamic), LC, Mod, File, _) --> !,
    parse_dynamics(Dynamic, LC, Mod, File, dynamic).
command(multifile(Dynamic), LC, Mod, File, _) --> !, % SP
    parse_dynamics(Dynamic, LC, Mod, File, multifile).
command(public(Public), LC, Mod, File, _) --> !, % SP
    parse_publics(Public, LC, Mod, File).
% command(extern(G), _, _, _, _) --> {predicate_property(G, built_in)}, !. % QP
% command(extern(G), LC, Mod, File, _) --> !, % QP
%     set_d_externs(E, [extern(File,LC,N1,A1,Mod)|E]),
%     { functor(G, N1, A1) }.
command(LoadCommand, _, M, F, L) -->
    {load_command(LoadCommand, Files, Options)}, !,
    load_files(Files, Options, M, F, L).
command(_, _, _, _, _) --> [].

parse_metas(M:X, _, F, LC, Wrn0, Wrn) --> !,
    parse_metas(X, M, F, LC, Wrn0, Wrn).
parse_metas((X,Y), Mod, F, LC, Wrn0, Wrn) --> !,
    parse_metas(X, Mod, F, LC, Wrn0, Wrn1),
    parse_metas(Y, Mod, F, LC, Wrn1, Wrn).
parse_metas(Meta, Mod, F, LC, Wrn0, Wrn, M0, M) :-
    functor(Meta, N, A),
    functor(X, N, A),
    parse_meta(A, Meta, X, L), !,
    (	get_assoc(g(N,A,Mod), M0, Old)
    ->	(   Old == none
	->  Wrn = [p(F,LC,late_meta_decl(N,A,Mod))|Wrn0]
	;   Wrn = [p(F,LC,duplicate_meta_decl(N,A,Mod))|Wrn0]
	)
    ;	Wrn = Wrn0
    ),
    put_assoc(g(N,A,Mod), M0, X-L, M).
parse_metas(Meta, _Mod, F, LC, Wrn0, Wrn) -->
	{Wrn = [p(F,LC,malformed(meta_predicate(Meta)))|Wrn0]}.

parse_meta(0, _, _, []) :- !.
parse_meta(A, Meta, X, L) :-
    (   arg(A, Meta, Arg),
        (   Arg == :
        ->  Extras = 0
	;   integer(Arg)
	->  Extras = Arg
	)
    ->  L = [H-Extras|T], arg(A, X, H)		% the crux of the biscuit
    ;   L = T
    ),
    B is A-1, parse_meta(B, Meta, X, T).

parse_dynamics((X,Y), LC, Mod, File, Decl) --> !,
    parse_dynamics(X, LC, Mod, File, Decl),
    parse_dynamics(Y, LC, Mod, File, Decl).
parse_dynamics(M:N/A, LC, _, File, _Decl) -->
    dynamic(N, A, LC, M, File), !.
parse_dynamics(N/A, LC, Mod, File, _Decl) -->
    dynamic(N, A, LC, Mod, File), !.
parse_dynamics(Spec, LC, _Mod, File, Decl) -->
	{Term =.. [Decl,Spec]},
	set_d_warnings(Wrn0, [p(File,LC,malformed(Term))|Wrn0]).

dynamic(foreign, 2, _, _, _) --> !.
dynamic(foreign, 3, _, _, _) --> !.
dynamic(foreign_file, 2, _, _, _) --> !.
dynamic(foreign_resource, 2, _, _, _) --> !.
dynamic(N, A, LC, Mod, File) -->
	{atom(N), integer(A)},
    insert_clause(N, A, true, Mod, LC, Mod, File).

parse_publics((X,Y), LC, Mod, File) --> !,
    parse_publics(X, LC, Mod, File),
    parse_publics(Y, LC, Mod, File).
parse_publics(M:N/A, LC, _, File) -->
    public(N, A, LC, M, File), !.
parse_publics(N/A, LC, Mod, File) -->
    public(N, A, LC, Mod, File), !.
parse_publics(Spec, LC, _Mod, File) -->
	set_d_warnings(Wrn0, [p(File,LC,malformed(public(Spec)))|Wrn0]).

public(N, A, LC, Mod, File) -->
	{atom(N), integer(A)},
    set_d_externs(E, [extern(File,LC,N,A,Mod)|E]).

load_command(load_files(Files, Options), Files, Options).
load_command(load_files(Files), Files, []).
load_command(include(Files), Files, []). % SP
load_command([H|T], [H|T], []).
load_command(compile(Files), Files, [load_type(compile)]).
load_command(consult(Files), Files, [load_type(compile)]).
load_command(ensure_loaded(Files), Files, [if(changed)]).
load_command(use_module(Files), Files, [must_be_module(yes)]).
load_command(use_module(Files,Imports), Files,
	     [must_be_module(yes),imports(Imports)]).
load_command(use_module(_, File, Imports), File,
	     [must_be_module(yes),imports(Imports)]) :- ground(File).

module_prefix(M:X, _, Head, HeadC) :- !,
    module_prefix(X, M, Head, HeadC).
module_prefix(Head, Mod, Head, Mod).

insert_clause(N, A, Y, HeadC, LC, BodyC, File) -->
    { functor(X, N, A) },
    insert_clause(X, Y, HeadC, LC, BodyC, File).

insert_clause(X, Y, HeadC, LC, BodyC, File) -->
    set_d_defs(T, [H|T]),
    get_d_imports(I),
    set_d_metas(Mt0, Mt),
    { H = G-clause(File,LC,Body),
      G = g(N,A,HeadC),
      functor(X, N, A),
      body(Y, x(G,N,A,LC,BodyC,File,I,Mt0), Body, []),
      record_non_metas(Body, Mt0, Mt)
    }.

body(X, M)                       --> {var(X)}, !, {cant_follow(M, X)}.
body((M:X), MM)                  --> !, change_mod(X, M, MM).
body((\+X), M)                   --> !, body(X, M).
body(abolish(X), M)              --> !, pred_spec_tree(abolish, 2, X, M).
body(assert(X), M)               --> !, parent(assert, 1, X, M).
body(asserta(X), M)              --> !, parent(asserta, 1, X, M).
body(assertz(X), M)              --> !, parent(assertz, 1, X, M).
body(call(X), M)                 --> !, parent(call, 1, X, M).
body(call_residue(X,_), M)       --> !, parent(call_residue, 2, X, M). % SP
body(call_cleanup(X,C), M)       --> !, parent(call_cleanup, 2, X, M), % SP
	                                parent(call_cleanup, 2, C, M).
body(undo(X), M)                 --> !, parent(undo, 1, X, M).
% body(multifile_assertz(X), M)  --> !, parent(multifile_assertz, 1, X, M). % QP
body(retract(X), M)              --> !, parent(retract, 1, X, M).
body(retractall(X), M)           --> !, parent(retractall, 1, X, M).
body((X,Y), M)                   --> !, body(X, M), body(Y, M).
body((X->Y), M)                  --> !, body(X, M), body(Y, M).
body((X;Y), M)                   --> !, body(X, M), body(Y, M).
body(_^X, M)                     --> !, body(X, M).
body(if(X,Y,Z), M)               --> !,	% SP
	body(X, M),
	body(Y, M),
	body(Z, M).
body(once(X), M)                 --> !, body(X, M). % SP
body(abolish(N,A), M)            --> !, pred_spec_tree(abolish, 2, N/A, M).
body(assert(X,_), M)             --> !, parent(assert, 2, X, M).
body(asserta(X,_), M)            --> !, parent(asserta, 2, X, M).
body(assertz(X,_), M)            --> !, parent(assertz, 2, X, M).
body(clause(X,_), M)             --> !, parent(clause, 2, X, M).
body(current_predicate(_,X), M)  --> !, parent(current_predicate, 2, X, M).
body(phrase(X,_), M)             --> !, phrase(phrase, 2, X, M).
body(predicate_property(X,_), M) --> !, parent(predicate_property, 2, X, M).
body(save_predicates(X,_), M)	 --> !, pred_spec_tree(save_predicates, 2, X, M).
body(spy(X), M)	                 --> !, pred_spec_tree(spy, 1, X, M). % SP
body(spy(X,_), M)                --> !, pred_spec_tree(spy, 2, X, M). % SP
body(nospy(X), M)                --> !, pred_spec_tree(nospy, 1, X, M). % SP
body(require(X), M)              --> !, pred_spec_tree(require, 1, X, M). % SP, TODO
body(listing(X), M)              --> !, pred_spec_tree(listing, 1, X, M). % SP
body(profile_data(X,_,_,_), M)   --> !, pred_spec_tree(profile_data, 4, X, M). % SP
body(profile_reset(X), M)        --> !, pred_spec_tree(profile_reset, 1, X, M). % SP
body(source_file(X,_), M)        --> !, parent(source_file, 2, X, M).
% body(add_advice(X,_,Y), M0)    --> !, {parent(add_advice, 3, M0, M)}, % QP
%     body(X, M), body(Y, M).
body(bagof(_,X,_), M)            --> !, parent(bagof, 3, X, M).
body(clause(X,_,_), M)           --> !, parent(clause, 3, X, M).
% body(current_advice(X,_,Y), M0)--> !, {parent(current_advice, 3, M0, M)}, % QP
%     body(X, M), body(Y, M).
body(findall(_,X,_), M)          --> !, parent(findall, 3, X, M).
body(findall(_,X,_,_), M)        --> !, parent(findall, 4, X, M). % SP
body(on_exception(_,X,Y), M0)    --> !, {parent(on_exception, 3, M0, M)},
	body(X, M),
	body(Y, M).
body(catch(X,_,Y), M0)           --> !, {parent(catch, 3, M0, M)}, % SP
	body(X, M),
	body(Y, M).
body(phrase(X,_,_), M)           --> !, phrase(phrase, 3, X, M).
body(setof(_,X,_), M)            --> !, parent(setof, 3, X, M).
body(source_file(X,_,_), M)      --> !, parent(source_file, 3, X, M).
body(X, _)                       --> {predicate_property(X, built_in)}, !.
body(X, MM)                      --> [G],
    {functor(X, N, A)},
    {arg(5, MM, M)},
    maybe_meta(X, MM, g(N,A,M), G).

change_mod(Body, M, X) --> {var(M)}, !,
    {cant_follow(X, Body)}.
change_mod(X, M, x(G,N,A,LC,_,F,I,Mt)) -->
    body(X, x(G,N,A,LC,M,F,I,Mt)).

cant_follow(X0, Body) :-
	callable(Body), !,
	functor(Body, N, A),
	parent(N, A, X0, X),
	cant_follow(X).
cant_follow(X, _) :-
	cant_follow(X).


cant_follow(x(G,N,A,LC,_,F,_,Mt)) :-
   (  functor(NF, N, A), need_not_follow(NF)
   -> true
   ;  get_assoc(G, Mt, _)
   -> true
   ;  g(Ng,Ag,Mg) = G, assert(cant_follow(N,A,Mg,Ng,Ag,F,LC))
   ).

need_not_follow(assert(_,_)).
need_not_follow(assert(_)).
need_not_follow(abolish(_)).
need_not_follow(abolish(_,_)).

parent(N, A, X, M0, S0, S) :-
    parent(N, A, M0, M),
    body(X, M, S0, S).

parent(N, A, x(G,_,_,LC,M,F,I,Mt), x(G,N,A,LC,M,F,I,Mt)).

pred_spec_tree(N, A, Tree, M0, S0, S) :- parent(N, A, M0, M),
    pred_spec_tree(Tree, M, S0, S).

pred_spec_tree([], _, S, S) :- !.
pred_spec_tree([H|T], M) --> !,
    pred_spec_tree(H, M),
    pred_spec_tree(T, M).
pred_spec_tree(M:_, MM, S, S) :- var(M), !,
    cant_follow(MM).
pred_spec_tree(M:X, x(G,N,A,LC,_,F,I,Mt)) --> !,
    pred_spec_tree(X, x(G,N,A,LC,M,F,I,Mt)).
pred_spec_tree(N/A, M, S, S) :- \+ (atom(N), integer(A)), !,
    cant_follow(M).
pred_spec_tree(N/A, M, S0, S) :-
    functor(X, N, A),
    body(X, M, S0, S).

phrase(Phrase, Ap, X, M0, S0, S) :-
    (   var(X)
    ->  S0 = S,
        parent(Phrase, Ap, M0, M),
        cant_follow(M)
    ;   expand_term((x-->X),(_:-Y)),
        body(Y, M0, S0, S)
    ).

maybe_meta(X, M0, G, G, S0, S) :-
    arg(8, M0, Metas),
    get_assoc(G, Metas, V),
    V \== none, !,
    copy_term(V, X-L),
    functor(X, N, A),
    parent(N, A, M0, M),
    meta(L, M, S0, S).
maybe_meta(X, M, G0, G, S0, S) :-
    arg(7, M, Imports),
    get_assoc(G0, Imports, G1), !,
    maybe_meta(X, M, G1, G, S0, S).
maybe_meta(_, _, G, G, S, S).

meta([], _) --> [].
meta([H-Extras|T], M) -->
    {   var(H)			% 3.9, was missing
    ->	H1 = H		% shortcut
    ;   Extras =:= 0
    ->	H1 = H		% shortcut
    ;	length(Tail, Extras),
	H =.. Front,
	append(Front, Tail, Whole),
	H1 =.. Whole
    },
    body(H1, M),
    meta(T, M).


%  Remember that we've seen calls to all the predicates in a clause body, so
%  if we haven't already seen a meta_predicate declaration for them, we
%  had better not see one later.

record_non_metas([], Mt, Mt).
record_non_metas([G|Gs], Mt0, Mt) :-
    (   get_assoc(G, Mt0, _)
    ->	Mt1 = Mt0
    ;	put_assoc(G, Mt0, none, Mt1)
    ),
    record_non_metas(Gs, Mt1, Mt).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% The list of clauses is converted into an avl tree.  The cross
% referencing is then done by following user:runtime_entry/1, publics, and
% initializations. Finally, the results are prepared for printing.

think(D, TraceRoot, MFile, UFile, Warnings, XREF, MMD) :-
    get_d_defs(Defs, D),
    get_d_imports(Imports, D),
    get_d_externs(Externs, D),
    get_d_initializations(INI, D),
    get_d_warnings(Warnings0, D),
    keysort(Defs, Sorted),
    merge_clauses(Sorted, Merged),
    ord_list_to_assoc(Merged, Def0),
    follow_top(TraceRoot, Imports, Externs, INI, Def0, Def),
    massage(Def, MFile, UFile, Warnings0, Warnings, XREF, MMD).

follow_top(TraceRoot, Imports, Externs, INI) -->
    follow_initializations(INI, Imports),
    (   {TraceRoot==exports}
    ->  {assoc_to_list(Imports, ImportList)},
	follow_imports(ImportList, Imports)
    ;   {Item = g(runtime_entry,1,user)},
	follow(Item, xref(Item), Imports)
    ),
    follow_hooks([message_hook/3, % SP/QP
		  generate_message_hook/3, % SP/QP
		  portray/1,	% SP/QP
		  query_hook/6,	% SP/QP
		  query_class_hook/5, % SP
		  query_input_hook/3, % SP
		  query_map_hook/4, % SP
		  unknown_predicate_handler/3, % SP/QP
		  user_help/0,	% SP/QP
		  term_expansion/2, % SP/QP
		  term_expansion/4, % SP
		  goal_expansion/3, % SP
		  debugger_command_hook/2, % SP
		  error_exception/1, % SP
		  portray_message/2 % SP
		 ], user, Imports),
    follow_hooks([generate_message/3, % SP/QP
		  query_abbreviation/3,	% SP/QP
		  query_class/5, % SP
		  query_input/3, % SP
		  query_map/4 % SP
		 ], 'SU_messages', Imports),
    follow_externs(Externs, Imports).

merge_clauses([], []).
merge_clauses([K-H|T0], [K-clauses([H|L])|R]) :-
    merge(T0, K, L, T),
    merge_clauses(T, R).

merge([K-H|T], K, [H|R], ML) :- !,
    merge(T, K, R, ML).
merge(T, _, [], T).

follow_initializations([], _) --> [].
follow_initializations([initialization(F,LC,B)|T], Imports) -->
    follow_body(B, initialization(F,LC), Imports),
    follow_initializations(T, Imports).

follow_body([], _, _) --> [].
follow_body([H|T], Referee, Imports) -->
    follow(H, Referee, Imports),
    follow_body(T, Referee, Imports).

follow(G, Referee, Imports, Def0, Def) :-
    (   get_assoc(G, Def0, V)
    ->  found(V, G, Referee, Imports, Def0, Def)
    ;   get_assoc(G, Imports, K)
    ->  follow(K, Referee, Imports, Def0, Def)
    ;   (   Referee == hook
	->  true
	;   undefined_ok(G)
	)
    ->  Def0 = Def
    ;   put_assoc(G, Def0, undefined([Referee]), Def)
    ).

found(clauses(Clauses), G, Referee, Imports, Def0, Def) :-
    collect_files(Clauses, Files1),
    to_ordset(Files1, Files, []),
    get_assoc(G, Def0, _, Def1, referenced(Files,[Referee])),
    g(N,A,M) = G,
    follow_bodies(Clauses, N, A, M, Imports, Def1, Def).
found(referenced(Files,R), G, Referee, _, Def0, Def) :-
    get_assoc(G, Def0, _, Def, referenced(Files,[Referee|R])).
found(undefined(R), G, Referee, _, Def0, Def) :-
    get_assoc(G, Def0, _, Def, undefined([Referee|R])).

collect_files([], _).
collect_files([clause(File,_,_)|T], Files) :-
    insert(File, Files),
    collect_files(T, Files).

insert(Name, dic(N,B,A)) :-
    (   Name = N
    ->  true
    ;   Name @< N
    ->  insert(Name, B)
    ;   insert(Name, A)
    ).

to_ordset(X) --> {var(X)}, !.
to_ordset(dic(N,B,A)) --> to_ordset(B), [N], to_ordset(A).

follow_bodies([], _, _, _, _) --> [].
follow_bodies([clause(File,LC,Body)|T], N, A, M, Imports) -->
    follow_body(Body, referee(File,LC,N,A,M), Imports),
    follow_bodies(T, N, A, M, Imports).

undefined_ok(g(N,A,M)) :- undefined_ok(N, A, M).

undefined_ok(file_search_path, 2, user).
undefined_ok(library_directory, 1, user).
% undefined_ok(parse_message, 3, 'SU_messages'). % QP
% undefined_ok(parse_message_hook, 3, user).     % QP
undefined_ok(_, _, prolog).	% SP

follow_hooks([], _, _) --> [].
follow_hooks([N/A|T], M, Imports) -->
    follow(g(N,A,M), hook, Imports),
    follow_hooks(T, M, Imports).

follow_externs([], _) --> [].
follow_externs([extern(F,LC,N,A,M)|T], Imports) -->
    follow(g(N,A,M), extern(F,LC), Imports),
    follow_externs(T, Imports).

follow_imports([], _) --> [].
follow_imports([Item-_|T], Imports) -->
	(   {Item=g(_,_,user)}
	->  follow(Item, xref(Item), Imports)
	;   []
	),
	follow_imports(T, Imports).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% get the data ready for output

massage(Def0, MFile, UFile, Warnings0, Warnings, XREF, MODULE_FINISH) :-
    assoc_to_list(Def0, L0),
    unreachable_files(L0, Def0, Def, t, UR1),
    assoc_to_list(UR1, UR2),
    unreachable_f(UR2, Warnings, W),
    assoc_to_list(Def, L),
    wx(L, UR1, UnsortedWarnings0, X),
    cnt_follow(UnsortedWarnings0, UnsortedWarnings1),
    append(Warnings0, UnsortedWarnings1, UnsortedWarnings),
    sort(UnsortedWarnings, W),
    sort(X, XREF),
    (   MFile == suppress
    ->  true
    ;   module_create(L, t, MODULE_CREATE),
        module_finish(MODULE_CREATE, MODULE_FINISH)
    ),
    maybe_collect_undefined(UFile, L).

% collect unreachable files and unreachable references to undefined predicates

unreachable_files([], Def, Def, D, D).
unreachable_files([K-V|T], D0, D) -->
    urf(V, K, D0, D1),
    unreachable_files(T, D1, D).

urf(clauses(Clauses), K, D0, D) -->
    urfc(Clauses, K, D0, D).
urf(referenced(Files,_), _, D, D) -->
    urfr(Files).
urf(undefined(_), _, Df, Df, D, D).

urfc([], _, Df, Df, D, D).
urfc([clause(File,LC,Body)|T], K, Df0, Df, D0, D) :-
    ur_body(Body, File, LC, K, Df0, Df1),
    urfcc(File, D0, D1),
    urfc(T, K, Df1, Df, D1, D).

ur_body([], _, _, _, D, D).
ur_body([H|T], File, LC, K, Def0, Def) :-
    (   get_assoc(H, Def0, V)
    ->  ur_found(V, H, File, LC, K, Def0, Def1)
    ;   put_assoc(H, Def0, undefined([not_called(File,LC,K)]), Def1)
    ),
    ur_body(T, File, LC, K, Def1, Def).

ur_found(clauses(_), _, _, _, _, D, D).
ur_found(referenced(_,_), _, _, _, _, D, D).
ur_found(undefined(U), H, File, LC, K, D0, D) :-
    get_assoc(H, D0, _, D, undefined([not_called(File,LC,K)|U])).

urfcc(File, Dic, Dic) :- get_assoc(File, Dic, _), !.
urfcc(File, Dic0, Dic) :- put_assoc(File, Dic0, unreachable, Dic).

urfr([], D, D).
urfr([H|T], D0, D) :-
    put_assoc(H, D0, reached, D1),
    urfr(T, D1, D).

unreachable_f([], S, S).
unreachable_f([F-K|T]) -->
    urfk(K, F),
    unreachable_f(T).

urfk(reached, _) --> [].
urfk(unreachable, F) --> [unreachable(F)].

% generate the cross reference list and the rest of the warnings
% wx ... warnings + cross reference

wx([], _, [], []).
wx([g(N,A,M)-V|T], UR, L0, X0) :- wx1(V, UR, N, A, M, L0, L, X0, X),
    wx(T, UR, L, X).

wx1(clauses([clause(F,LC,_)|_]), UR, N, A, M, [p(F,LC,not_reached(N,A,M))|L], L,
   X, X) :- get_assoc(F, UR, reached), !.
wx1(clauses(_), _, _, _, _, L, L, X, X).
wx1(undefined(_), _, N, A, M, L, L, X, X) :-
	undefined_ok(N, A, M), !.
wx1(undefined(R), _, N, A, M, L0, L, X, X) :-
	undefined(R, N, A, M, L0, L).
wx1(referenced(Files, R), _, N, A, M, L, L, [ref(M,N,A,Files,RS)|X], X) :-
    referenced(R, R1),
    to_ordset(R1, RS, []).

undefined([], _, _, _) --> [].
undefined([H|T], N, A, M) -->
    undefined1(H, N, A, M),
    undefined(T, N, A, M).

undefined1(xref(Item),            _,  _,  _) -->
    [undefined(Item)].
undefined1(referee(F,LC,N,A,M),  N1, A1, M1) -->
    [p(F,LC,referenced(M1,N1,A1,M,N,A))].
undefined1(initialization(F,LC), N,   A,  M) -->
    [p(F,LC,initialization(N,A,M))].
undefined1(extern(F,LC),         N,   A,  M) -->
    [p(F,LC,extern(N,A,M))].
undefined1(not_called(F,LC,K), N, A, M) -->
    [p(F,LC,not_called(M,N,A,K))].

referenced([], _).
referenced([H|T], D) :-
    referenced1(H, D),
    referenced(T, D).

referenced1(xref(_), _). 
referenced1(referee(_,_,N,A,M),   D) :- insert(referee(M,N,A),       D).
referenced1(initialization(F,LC), D) :- insert(initialization(F,LC), D).
referenced1(extern(F,LC),         D) :- insert(extern(F,LC),         D).
referenced1(hook,                 D) :- insert(hook,                 D).

cnt_follow(L0, L) :-
    findall(p(F,LC,cant_follow(N,A,Mg,Ng,Ag)),
	    retract(cant_follow(N,A,Mg,Ng,Ag,F,LC)), X),
    append(L0, X, L).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% create the data structures for module file output

module_create([], D, D).
module_create([G-H|T], D0, D) :- module_create1(H, G, D0, D1),
    module_create(T, D1, D).

module_create1(clauses(_),        _, D,  D).
module_create1(undefined(_),      _, D,  D).
module_create1(referenced([F],R), G, D0, D) :- !, % don't know how to do
    module_create2(R, F, G, D0, D).		  % multifile yet
module_create1(referenced(_,_),   _, D,  D).

module_create2([], _, _, D, D).
module_create2([H|T], F, G, D0, D) :-
    module_create3(H, F, G, D0, D1),
    module_create2(T, F, G, D1, D).

module_create3(xref(_),              F, G, D0, D) :- ei(user, F, G, D0, D).
module_create3(hook,                 _, _, D,  D).
module_create3(initialization(F,_),  F, _, D,  D) :- !.
module_create3(initialization(FI,_), F, G, D0, D) :- ei(FI, F, G, D0, D).
module_create3(extern(F,_),          F, _, D,  D) :- !.
module_create3(extern(FI,_),         F, G, D0, D) :- ei(FI, F, G, D0, D).
module_create3(referee(F,_,_,_,_),   F, _, D,  D) :- !.
module_create3(referee(FI,_,_,_,_),  F, G, D0, D) :- ei(FI, F, G, D0, D).

% ei ... exports imports. This is fun. We have an avl tree whose keys
% are file names and whose values are pairs. The left member of a pair
% is an absorptive key tree indicating the predicates exported, the
% right member is an absorptive key-value tree, the keys of which are
% imported file names, and the values of which are absorptive key trees
% indicating the predicates imported. The terminology is my own. Sorry.

ei(ImportingFile, ExportingFile, g(Name,Arity,_), D0, D) :-
    Goal = [Name|Arity],
    fetchm(ExportingFile, D0, Exports, _, D1),
    insert(Goal, Exports),
    fetchm(ImportingFile, D1, _, ImportedFiles, D),
    insert(ExportingFile, ImportedFiles, Imports),
    insert(Goal, Imports).

fetchm(K,  A, E, I, A) :- get_assoc(K,  A, E-I), !.
fetchm(K, A0, E, I, A) :- put_assoc(K, A0, E-I, A).

insert(Name, dic(N,V,B,A), Value) :-
    (   Name = N
    ->  Value = V
    ;   Name @< N
    ->  insert(Name, B, Value)
    ;   insert(Name, A, Value)
    ).

module_finish(D, L) :-
    assoc_to_list(D, L1),
    module_finish1(L1, L).

module_finish1([], []).
module_finish1([F-(E-I)|T], [x(F,Exports,Imports)|R]) :-
    to_ordset(E, Exports, []),
    m_imports(I, Imports, []),
    module_finish1(T, R).

m_imports(D, S, S) :- var(D), !.
m_imports(dic(N,V,B,A), S0, S) :-
    m_imports(B, S0, [N-X|S1]),
    to_ordset(V, X, []),
    m_imports(A, S1, S).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

maybe_collect_undefined(suppress, _).
maybe_collect_undefined(file(UFile), L) :-
    collect_undefined(L, t, U0),
    assoc_to_list(U0, U),
    telling(Telling),
    tell(UFile),
    print_undefined(U),
    told,
    tell(Telling).

collect_undefined([], X, X).
collect_undefined([G-H|T], D0, D) :-
    cu(H, G, D0, D1),
    collect_undefined(T, D1, D).

cu(undefined(_), G, D0, D) :- !,
    put_assoc(G, D0, foo, D).
cu(_, _, X, X).

print_undefined([]).
print_undefined([g(N,A,M)-_|T]) :-
	(   M==prolog -> true
	;   writeq(M:N/A), nl
	),
	print_undefined(T).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% print it

print_it(WFile, Warnings, XFile, XREF, MFile, MODULE_FINISH, CompilerErrors) :-

    print_warnings(WFile, Warnings, CompilerErrors),
    print_cross_references(XFile, XREF),
    print_modules(MFile, MODULE_FINISH).

% print the warnings

print_warnings(File, Warnings, CE) :-
    telling(T),
    tell(File),
    print_warnings_top(Warnings, CE),
    told,
    tell(T).

print_warnings_top(Warnings, CE) :-
    length(Warnings, L),
    print_warning_list(Warnings, foo(boo), CE), nl,
    write(L),
    write(' warnings'), nl.

print_warning_list([], _, _).
print_warning_list([P|T], Old, CE) :-
    print_warning(P, Old, F, CE), nl,
    print_warning_list(T, F, CE).

print_warning(undefined(g(N,A,M)), O, O, _) :-
	write_pred_spec(M, N, A),
	write(' is not defined').
print_warning(unreachable(F), O, O, _) :-
    write('nothing in file '),
    write(F),
    write(' was called').
print_warning(p(F,LC,Ms), O, F, CE) :-
   (  CE == normal
   -> (  O == F
      -> true
      ;  nl, write(F), nl
      ),
      write('    '), write(LC)
   ;  format('~w:~w:', [F,LC])
   ),
   print_warning(Ms).

print_warning(not_reached(N,A,M)) :-
    write(' unreachable '),
    write_pred_spec(M, N, A).
print_warning(referenced(Mu,Nu,Au,M,N,A)) :-
    write(' '),
    referenced_undefined(M, N, A, Mu, Nu, Au).
print_warning(initialization(N,A,M)) :-
    write(' initialization refers to undefined predicate '),
    write_pred_spec(M, N, A).
print_warning(extern(N,A,M)) :-
    write(' public declaration for undefined predicate '),
    write_pred_spec(M, N, A).
print_warning(not_called(Mu,Nu,Au,g(N,A,M))) :-
    write(' unreachable '),
    referenced_undefined(M, N, A, Mu, Nu, Au).
print_warning(cant_follow(N,A,Mg,Ng,Ag)) :-
    write(' can not follow '),
    writeq(N/A),
    write(' in '),
    write_pred_spec(Mg, Ng, Ag).
print_warning(late_meta_decl(N,A,M)) :-
    write(' meta_predicate declaration appears after use of predicate '),
    write_pred_spec(M, N, A).
print_warning(duplicate_meta_decl(N,A,M)) :-
    write(' repeated meta_predicate declaration for predicate '),
    write_pred_spec(M, N, A).
print_warning(malformed(Spec)) :-
    write(' malformed declaration '),
    writeq(Spec).

write_pred_spec(M, N, A) :-
	writeq(M:N/A).

referenced_undefined(M, N, A, Mu, Nu, Au) :-
    write_pred_spec(M, N, A),
    write(' referenced undefined '),
    write_pred_spec(Mu, Nu, Au).

% print the cross reference listing

print_cross_references(suppress, _).
print_cross_references(file(XFile), X) :-
    telling(T),
    tell(XFile),
    print_xref(X),
    told,
    tell(T).

print_xref(X) :-
    length(X, L),
    format('~d referenced predicates~n', [L]),
    print_xref_list(X).

print_xref_list([]).
print_xref_list([ref(M,N,A,Files,References)|T]) :- nl,
    write_pred_spec(M, N, A), nl,
    print_files(Files),
    print_references(References),
    print_xref_list(T).

print_files([]).
print_files([H|T]) :-
    write('  '),
    write(H), nl,
    print_files(T).

print_references([]).
print_references([H|T]) :-
    write('    '),
    print_reference(H), nl,
    print_references(T).

print_reference(referee(M,N,A)) :-
    write_pred_spec(M, N, A).
print_reference(initialization(F,LC)) :-
    write(initialization), line_ref(F, LC).
print_reference(extern(F,LC)) :-
    write('public declaration'),
    line_ref(F, LC).
print_reference(hook)         :-
    write(hook).

line_ref(F, LC) :-
    write(' in file '),
    write(F),
    write(' at line '),
    write(LC).

% print the imports & exports file

print_modules(suppress, _).
print_modules(file(MFile), X) :-
    telling(T),
    tell(MFile),
    print_module(X),
    told,
    tell(T).

print_module([]).
print_module([x(F,Exports,Imports)|T]) :-
	(   F==user -> true
	;   module_of_file(F, N),
	    format('% ~a ~2n:- module(~a, [~n', [F,N]),
	    print_module_exports(Exports, ''),
	    format(']).~2n', []),
	    print_module_imports(Imports), nl
	),
	print_module(T).

module_of_file(File, Module) :-
    open(File, read, S),
    read_one(S, Term, _),
    (   (Term = (:-module(M,_)); Term = (:-module(M,_,_)))
    ->  Module = M
    ;   Module = user
    ),
    close(S).	

print_module_exports([], _).
print_module_exports([[N|A]|T], Suffix) :-
    format(Suffix, []),
    format('			~q', [N/A]),
    print_module_exports(T, ',~n').

print_module_imports([]).
print_module_imports([F-H|T]) :-
    format(':- use_module(~q, [~n', [F]),
    print_module_exports(H, ''),
    format(']).~2n', []),
    print_module_imports(T).


/* ----------------------------------------------------------------------
    Messages
   ---------------------------------------------------------------------- */

:- multifile user:generate_message_hook/3.
:- dynamic   user:generate_message_hook/3.

user:generate_message_hook(xref(Verbose,What)) --> !,
    verbose_or_silent(Verbose, What).

verbose_or_silent(silent, _) --> [].
verbose_or_silent(verbose, What) -->
    verbose(What).

verbose(Msg) --> {atom(Msg)}, !, [Msg-[],nl].
verbose(processing(Level,File)) --> ['~*c~a'-[Level,32,File],nl].


/* ----------------------------------------------------------------------
    Application extras
   ---------------------------------------------------------------------- */

usage :- write(user_error,
'usage: spxref [-R] [-c] [-v] [-i ifile] [-w wfile] [-x xfile] [-m ufile] [-u ufile] fspec ...

  -R ......... follow user:runtime_entry/1 as opposed to module declarations
  -c ......... generate standard compiler style error messages
  -v ......... verbose output. This echoes the names of the files being read to
	       stderr.
  -i ifile ... an initialization file. Read in prior to processing.
  -w wfile ... warning file. Warnings are written to stderr by default.
  -x xfile ... cross reference file. This is not generated by default.
  -m mfile ... generate a file indicating which predicates are imported and
	       which are exported for each file. This is not generated by
	       default.
  -u ufile ... generate a file listing all the undefined predicates.  This is
	       not generated by default.
  fspec ...... one or more filenames, ".pl" extensions optional

The cross referencer follows initializations, hooks, user:runtime_entry/1, 
and module and public declarations.
').

% :- use_module(library(charsio)).
% :- use_module(messages(language('QU_messages'))).

user:runtime_entry(start) :-
	prolog_flag(argv, Args),
	parse(Args, Files, Options),
	functor(Files, '.', 2), !,
	xref(Files, Options).
user:runtime_entry(start) :-
	usage,
	prolog_flag(system_type, runtime),
	halt(1).

parse([], [], []).
parse([H,A|R], F, L0) :-
    prs(H, A, L0, L), !,
    parse(R, F, L).
parse([H|T], F, L0) :-
    atom_chars(H, [0'-|V]), !,
    prsc(V, L0, L),
    parse(T, F, L).
parse([H|T], [F|R], L) :-
    fn(H, F),
    parse(T, R, L).

prs('-i', A,                    L, L) :- fn(A, IFile), compile(IFile).
prs('-m', A,       [mod(MFile)|L], L) :- fn(A, MFile).
prs('-w', A,  [warnings(WFile)|L], L) :- fn(A, WFile).
prs('-u', A, [undefined(UFile)|L], L) :- fn(A, UFile).
prs('-x', A,      [xref(XFile)|L], L) :- fn(A, XFile).

prsc([], L, L).
prsc([H|T], L0, L) :-
    prsc1(H, L0, L1),
    prsc(T, L1, L).

prsc1(0'R, [runtime_entry|L], L).
prsc1(0'c, [compiler_errors|L], L).
prsc1(0'v, [verbose|L], L).

fn(-, user) :- !.
fn(A, A).

% %% An appempt to handle 'library(foo)' etc.?
% fn(A, F) :-
% 	prolog_flag(syntax_errors, Old, quiet),
% 	name(A, C),
% 	(   chars_to_term(C, F),
% 	    \+ functor(F, /, 2)
% 	->  true
% 	;   F = A
% 	),
% 	prolog_flag(syntax_errors, _, Old).

end_of_file.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- use_module(library(addportray)).
:- use_module(library(files)).

my_avl_portrayal(node(_,_,_,_,_)) :- write(avl).

:- add_portray(my_avl_portrayal).

av(N, A) :- functor(X, N, A), add_advice(X, fail, trace).

clean :- close_all_streams, retractall(visited(_)),
    (current_advice(X,Y,Z), remove_advice(X, Y, Z), fail ; true),
    av(load_files, 7), av(body, 4), av(think, 5), av(follow, 5),
    av(massage, 7), av(unreachable_files, 5), av(print_it, 6),
    check_advice.

t(X) :- xref(X, [verbose]).
tm(X) :- xref(X, [mod('/tmp/mod'),verbose]).

